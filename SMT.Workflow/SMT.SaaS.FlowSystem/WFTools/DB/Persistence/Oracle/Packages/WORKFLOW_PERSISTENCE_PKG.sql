CREATE OR REPLACE PACKAGE WORKFLOW_PERSISTENCE_PKG AS
	-- TODO Strongly-typed ref cursors
	TYPE RefCursor IS REF CURSOR;

	-- WorkflowStatus enum values
	c_STATUS_RUNNING CONSTANT NUMBER := 0;
	c_STATUS_COMPLETED CONSTANT NUMBER := 1;
	c_STATUS_SUSPENDED CONSTANT NUMBER := 2;
	c_STATUS_TERMINATED CONSTANT NUMBER := 3;
	c_STATUS_CREATED CONSTANT NUMBER := 4;

	-- Result return codes
	c_RESULT_SUCCESS CONSTANT NUMBER := 0;
	c_RESULT_INSTANCE_NOT_FOUND CONSTANT NUMBER := -1;
	c_RESULT_OWNERSHIP_CONFLICT CONSTANT NUMBER := -2;	
	
	PROCEDURE InsertInstanceState
	(
		p_INSTANCE_ID IN INSTANCE_STATE.INSTANCE_ID%TYPE
		,p_STATE IN INSTANCE_STATE.STATE%TYPE
		,p_STATUS IN INSTANCE_STATE.STATUS%TYPE
		,p_UNLOCKED IN INSTANCE_STATE.UNLOCKED%TYPE
		,p_BLOCKED IN INSTANCE_STATE.BLOCKED%TYPE
		,p_INFO IN INSTANCE_STATE.INFO%TYPE
		,p_OWNER_ID IN INSTANCE_STATE.OWNER_ID%TYPE
		,p_OWNED_UNTIL IN INSTANCE_STATE.OWNED_UNTIL%TYPE
		,p_NEXT_TIMER IN INSTANCE_STATE.NEXT_TIMER%TYPE
		,p_RESULT OUT NUMBER
		,p_CURRENT_OWNER_ID OUT INSTANCE_STATE.OWNER_ID%TYPE
	);

	PROCEDURE InsertCompletedScope
	(
		p_INSTANCE_ID IN COMPLETED_SCOPE.INSTANCE_ID%TYPE
		,p_COMPLETED_SCOPE_ID IN COMPLETED_SCOPE.COMPLETED_SCOPE_ID%TYPE
		,p_STATE IN COMPLETED_SCOPE.STATE%TYPE
	);
	
	PROCEDURE RetrieveNonblockingInstanceIds
	(
		p_OWNER_ID IN INSTANCE_STATE.OWNER_ID%TYPE := NULL
		,p_OWNED_UNTIL IN INSTANCE_STATE.OWNED_UNTIL%TYPE := NULL
		,p_NOW IN DATE
		,p_WORKFLOW_IDS OUT RefCursor
	);
	
	PROCEDURE RetrieveExpiredTimerIds
	(
		p_OWNER_ID in INSTANCE_STATE.OWNER_ID%TYPE := NULL
		,p_OWNED_UNTIL IN INSTANCE_STATE.OWNED_UNTIL%TYPE := NULL
		,p_NOW IN DATE
		,p_WORKFLOW_IDS OUT RefCursor
	);		

	PROCEDURE RetrieveInstanceState
	(
		p_INSTANCE_ID IN INSTANCE_STATE.INSTANCE_ID%TYPE
		,p_OWNER_ID IN INSTANCE_STATE.OWNER_ID%TYPE := NULL
		,p_OWNED_UNTIL IN INSTANCE_STATE.OWNED_UNTIL%TYPE := NULL
		,p_RESULT OUT NUMBER
		,p_CURRENT_OWNER_ID OUT INSTANCE_STATE.OWNER_ID%TYPE
		,p_STATE OUT RefCursor
	);

	PROCEDURE RetrieveCompletedScope
	(
		p_COMPLETED_SCOPE_ID IN COMPLETED_SCOPE.COMPLETED_SCOPE_ID%TYPE
		,p_RESULT OUT NUMBER
		,p_STATE OUT RefCursor
	);
	
	PROCEDURE UnlockInstanceState
	(
		p_INSTANCE_ID IN INSTANCE_STATE.INSTANCE_ID%TYPE
		,p_OWNER_ID IN INSTANCE_STATE.OWNER_ID%TYPE := NULL
	);

END WORKFLOW_PERSISTENCE_PKG;
/

CREATE OR REPLACE PACKAGE BODY WORKFLOW_PERSISTENCE_PKG AS
	PROCEDURE InsertInstanceState
	(
		p_INSTANCE_ID IN INSTANCE_STATE.INSTANCE_ID%TYPE
		,p_STATE IN INSTANCE_STATE.STATE%TYPE
		,p_STATUS IN INSTANCE_STATE.STATUS%TYPE
		,p_UNLOCKED IN INSTANCE_STATE.UNLOCKED%TYPE
		,p_BLOCKED IN INSTANCE_STATE.BLOCKED%TYPE
		,p_INFO IN INSTANCE_STATE.INFO%TYPE
		,p_OWNER_ID IN INSTANCE_STATE.OWNER_ID%TYPE
		,p_OWNED_UNTIL IN INSTANCE_STATE.OWNED_UNTIL%TYPE
		,p_NEXT_TIMER IN INSTANCE_STATE.NEXT_TIMER%TYPE
		,p_RESULT OUT NUMBER
		,p_CURRENT_OWNER_ID OUT INSTANCE_STATE.OWNER_ID%TYPE
	)
	AS
		l_NOW DATE := SYS_EXTRACT_UTC(SYSTIMESTAMP);
		l_EXISTS NUMBER := NULL;
	BEGIN
		p_RESULT := c_RESULT_SUCCESS;
		p_CURRENT_OWNER_ID := p_OWNER_ID;
		
		IF p_STATUS = c_STATUS_COMPLETED OR p_STATUS = c_STATUS_TERMINATED
		THEN
			-- remove all instance state and completed scopes
			DELETE FROM INSTANCE_STATE
			WHERE
				INSTANCE_ID = p_INSTANCE_ID
				AND (
					(OWNER_ID = p_OWNER_ID AND OWNED_UNTIL >= l_NOW)
					OR (OWNER_ID IS NULL AND OWNED_UNTIL IS NULL)
				);
				
			DELETE FROM COMPLETED_SCOPE
			WHERE
				INSTANCE_ID = p_INSTANCE_ID;
		ELSE
			SELECT
				COUNT(*)
			INTO
				l_EXISTS
			FROM
				DUAL
			WHERE
				EXISTS (SELECT NULL FROM INSTANCE_STATE WHERE INSTANCE_ID = p_INSTANCE_ID);
				
			IF l_EXISTS = 0
			THEN
				-- instance state doesn't exist, add a new one
				IF p_UNLOCKED = 0
				THEN
					INSERT INTO INSTANCE_STATE
					(
						INSTANCE_ID ,STATE ,STATUS
						,UNLOCKED ,BLOCKED ,INFO ,MODIFIED
						,OWNER_ID ,OWNED_UNTIL ,NEXT_TIMER
					)
					VALUES
					(
						p_INSTANCE_ID ,p_STATE ,p_STATUS
						,p_UNLOCKED ,p_BLOCKED ,p_INFO ,l_NOW
						,p_OWNER_ID ,p_OWNED_UNTIL ,p_NEXT_TIMER
					);
				ELSE
					INSERT INTO INSTANCE_STATE
					(
						INSTANCE_ID ,STATE ,STATUS
						,UNLOCKED ,BLOCKED ,INFO ,MODIFIED
						,OWNER_ID ,OWNED_UNTIL ,NEXT_TIMER
					)
					VALUES
					(
						p_INSTANCE_ID ,p_STATE ,p_STATUS
						,p_UNLOCKED ,p_BLOCKED ,p_INFO ,l_NOW
						,NULL ,NULL ,p_NEXT_TIMER
					);
				END IF;
			ELSE
				-- it does exist, update the existing instance
				IF p_UNLOCKED = 0
				THEN
					UPDATE INSTANCE_STATE
					SET
						STATE = p_STATE
						,STATUS = p_STATUS
						,UNLOCKED = p_UNLOCKED
						,BLOCKED = p_BLOCKED
						,INFO = p_INFO
						,MODIFIED = l_NOW
						,OWNER_ID = p_OWNER_ID
						,OWNED_UNTIL = p_OWNED_UNTIL
						,NEXT_TIMER = p_NEXT_TIMER
					WHERE
						INSTANCE_ID = p_INSTANCE_ID
						AND (
							(OWNER_ID = p_OWNER_ID AND OWNED_UNTIL >= l_NOW)
							OR (OWNER_ID IS NULL AND OWNED_UNTIL IS NULL)
						);
				ELSE
					UPDATE INSTANCE_STATE
					SET
						STATE = p_STATE
						,STATUS = p_STATUS
						,UNLOCKED = p_UNLOCKED
						,BLOCKED = p_BLOCKED
						,INFO = p_INFO
						,MODIFIED = l_NOW
						,OWNER_ID = NULL
						,OWNED_UNTIL = NULL
						,NEXT_TIMER = p_NEXT_TIMER
					WHERE
						INSTANCE_ID = p_INSTANCE_ID;
				END IF;
			END IF;					
		END IF;
		
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				SELECT OWNER_ID
				INTO p_CURRENT_OWNER_ID
				FROM INSTANCE_STATE
				WHERE
					INSTANCE_ID = p_INSTANCE_ID;
					
				IF p_CURRENT_OWNER_ID IS NOT NULL
				THEN
					p_RESULT := c_RESULT_OWNERSHIP_CONFLICT;
				ELSE
					p_RESULT := c_RESULT_INSTANCE_NOT_FOUND;
				END IF;
			WHEN OTHERS THEN
				RAISE;

	END InsertInstanceState;
		
	PROCEDURE InsertCompletedScope
	(
		p_INSTANCE_ID IN COMPLETED_SCOPE.INSTANCE_ID%TYPE
		,p_COMPLETED_SCOPE_ID IN COMPLETED_SCOPE.COMPLETED_SCOPE_ID%TYPE
		,p_STATE IN COMPLETED_SCOPE.STATE%TYPE
	)
	AS
		l_NOW DATE := SYS_EXTRACT_UTC(SYSTIMESTAMP);
	BEGIN
		-- attempt to update first
		UPDATE COMPLETED_SCOPE
		SET
			STATE = p_STATE
			,MODIFIED = l_NOW
		WHERE
			COMPLETED_SCOPE_ID = p_COMPLETED_SCOPE_ID;

		IF NVL(SQL%ROWCOUNT, 0) = 0
		THEN
			-- no rows updated, perform an insert instead
			INSERT INTO COMPLETED_SCOPE
			(
				INSTANCE_ID
				,COMPLETED_SCOPE_ID
				,STATE
				,MODIFIED
			)
			VALUES
			(
				p_INSTANCE_ID
				,p_COMPLETED_SCOPE_ID
				,p_STATE
				,l_NOW
			);
		END IF;
	END;
	
	PROCEDURE RetrieveNonblockingInstanceIds
	(
		p_OWNER_ID IN INSTANCE_STATE.OWNER_ID%TYPE := NULL
		,p_OWNED_UNTIL IN INSTANCE_STATE.OWNED_UNTIL%TYPE := NULL
		,p_NOW IN DATE
		,p_WORKFLOW_IDS OUT RefCursor
	)
	AS
	BEGIN
		OPEN p_WORKFLOW_IDS FOR
			SELECT
				INSTANCE_ID
			FROM
				INSTANCE_STATE
			WHERE
				BLOCKED = 0
				AND STATUS NOT IN (c_STATUS_COMPLETED, c_STATUS_SUSPENDED, c_STATUS_TERMINATED)
				AND (OWNER_ID IS NULL OR OWNED_UNTIL < p_NOW)
			FOR UPDATE;

		IF NVL(SQL%ROWCOUNT, 0) > 0
		THEN
			UPDATE INSTANCE_STATE
			SET
				OWNER_ID = p_OWNER_ID
				,OWNED_UNTIL = p_OWNED_UNTIL
			WHERE
				BLOCKED = 0
				AND STATUS NOT IN (c_STATUS_COMPLETED, c_STATUS_SUSPENDED, c_STATUS_TERMINATED)
				AND (OWNER_ID IS NULL OR OWNED_UNTIL < p_NOW);
		END IF;
	END;
	
	PROCEDURE RetrieveExpiredTimerIds
	(
		p_OWNER_ID in INSTANCE_STATE.OWNER_ID%TYPE := NULL
		,p_OWNED_UNTIL IN INSTANCE_STATE.OWNED_UNTIL%TYPE := NULL
		,p_NOW IN DATE
		,p_WORKFLOW_IDS OUT RefCursor
	)
	AS
	BEGIN
		OPEN p_WORKFLOW_IDS FOR
			SELECT
				INSTANCE_ID
			FROM
				INSTANCE_STATE
			WHERE
				NEXT_TIMER < p_NOW
				AND STATUS NOT IN (c_STATUS_COMPLETED, c_STATUS_SUSPENDED, c_STATUS_TERMINATED)
				AND (
					(UNLOCKED = 1 AND OWNER_ID IS NULL)
					OR (OWNED_UNTIL < p_NOW)
				);
	END;

	PROCEDURE RetrieveInstanceState
	(
		p_INSTANCE_ID IN INSTANCE_STATE.INSTANCE_ID%TYPE
		,p_OWNER_ID IN INSTANCE_STATE.OWNER_ID%TYPE := NULL
		,p_OWNED_UNTIL IN INSTANCE_STATE.OWNED_UNTIL%TYPE := NULL
		,p_RESULT OUT NUMBER
		,p_CURRENT_OWNER_ID OUT INSTANCE_STATE.OWNER_ID%TYPE
		,p_STATE OUT RefCursor
	)
	AS
	BEGIN
		-- REVIEW - check this...
		-- SQL Server implementation uses REPEATABLE READ
		-- transaction isolation - Oracle's default is
		-- READ COMMITTED and its implementation allows
		-- repeatable reads (hooray for snapshots!).
		
		IF p_OWNER_ID IS NOT NULL
		THEN
			-- reading state for ownership
			UPDATE INSTANCE_STATE
			SET
				OWNER_ID = p_OWNER_ID
				,OWNED_UNTIL = p_OWNED_UNTIL
			WHERE
				INSTANCE_ID = p_INSTANCE_ID
				AND (
					(OWNER_ID = p_OWNER_ID)
					OR (OWNER_ID IS NULL AND OWNED_UNTIL < SYS_EXTRACT_UTC(SYSTIMESTAMP))
				);
		END IF;
		
		OPEN p_STATE FOR
			SELECT
				STATE
			FROM
				INSTANCE_STATE
			WHERE
				INSTANCE_ID = p_INSTANCE_ID;

		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				SELECT OWNER_ID
				INTO p_CURRENT_OWNER_ID
				FROM INSTANCE_STATE
				WHERE
					INSTANCE_ID = p_INSTANCE_ID;
					
				IF p_CURRENT_OWNER_ID IS NOT NULL
				THEN
					p_RESULT := c_RESULT_OWNERSHIP_CONFLICT;
				ELSE
					p_RESULT := c_RESULT_INSTANCE_NOT_FOUND;
				END IF;
			WHEN OTHERS THEN
				RAISE;
	END;

	PROCEDURE RetrieveCompletedScope
	(
		p_COMPLETED_SCOPE_ID IN COMPLETED_SCOPE.COMPLETED_SCOPE_ID%TYPE
		,p_RESULT OUT NUMBER
		,p_STATE OUT RefCursor
	)
	AS
	BEGIN
		OPEN p_STATE FOR
			SELECT
				STATE
			FROM
				COMPLETED_SCOPE
			WHERE
				COMPLETED_SCOPE_ID = p_COMPLETED_SCOPE_ID;
				
		p_RESULT := NVL(SQL%ROWCOUNT, 0);
	END;
	
	PROCEDURE UnlockInstanceState
	(
		p_INSTANCE_ID IN INSTANCE_STATE.INSTANCE_ID%TYPE
		,p_OWNER_ID IN INSTANCE_STATE.OWNER_ID%TYPE := NULL
	)
	AS
	BEGIN
		UPDATE INSTANCE_STATE
		SET
			OWNER_ID = NULL
			,OWNED_UNTIL = NULL
		WHERE
			INSTANCE_ID = p_INSTANCE_ID
			AND (
				(OWNER_ID = p_OWNER_ID AND OWNED_UNTIL < SYS_EXTRACT_UTC(SYSTIMESTAMP))
				OR
				(OWNER_ID IS NULL AND p_OWNER_ID IS NULL)
			);
			
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				RETURN;
			WHEN OTHERS THEN
				RAISE;

	END;
END WORKFLOW_PERSISTENCE_PKG;
/
